/*========================================================================
 *
 * Sample MATLAB invocation:
 *
 * [sc, al] = CARLIN_def.cas9_align_cpp([0 nt2int(seq)], ...
 *                                      [0 nt2int(refseq)], ...
 *                                      open_penalty, ...
 *                                      [0 close_penalty], ...
 *                                      padarray(match, [1 1], 'pre'));
 *
 *======================================================================*/

#include "mex.h"
#include "cas9_align.hpp"

#ifndef NDEBUG

void cas9_check_input(const unsigned char *seq, size_t Lseq, 
                      const unsigned char *ref, size_t Lref,
                      const double* open_penalty, const double* close_penalty,
                      const double* sub_score)
{
                
    mwSize total_num_of_elements, index;
    
    mexPrintf("Length: Seq=%d Ref=%d\n", Lseq, Lref);

    mexPrintf("Sequence:\n");
    for (int j = 0; j <= Lseq; j++){
        mexPrintf("%d\t", seq[j]);
    }
    mexPrintf("\n");
    
    mexPrintf("Reference:\n");
    for (int k = 0; k <= Lref; k++){
        mexPrintf("%d\t", ref[k]);
    }
    mexPrintf("\n");
    
    mexPrintf("Opening Penalty:\n");
    for (int k = 0; k <= Lref; k++){
        mexPrintf("%5.3g\t", open_penalty[k]);
    }
    mexPrintf("\n");
    
    mexPrintf("Closing Penalty:\n");
    for (int k = 0; k <= Lref; k++){
        mexPrintf("%5.3g\t", close_penalty[k]);
    }
    mexPrintf("\n");
    
    mexPrintf("Substitution Score Matrix:\n");
    for (int j = 1; j <= 4; j++){
        for (int k = 1; k <= 4; k++){
            mexPrintf("%5.3g\t", sub_score[j*5+k]);
        }
        mexPrintf("\n");
    }
    mexPrintf("\n");
}

#endif
             
/* Main for MATLAB functions */ 
void mexFunction(int nlhs, mxArray* plhs[],
                 int nrhs, const mxArray* prhs[]) {

    /* Argument validation */
    
    if(nrhs != 5) {
        mexErrMsgIdAndTxt("MATLAB:cas9_align:nargin",
                          "MEXCPP for cas9_align requires five input arguments.");
    }
    if(nlhs > 2) {
        mexErrMsgIdAndTxt("MATLAB:cas9_align:nargout",
                          "MEXCPP for cas9_align has at most two output arguments.");
    }
    
    if (mxGetClassID(prhs[0]) != mxUINT8_CLASS || (mxGetM(prhs[0]) != 1) )  {
	    mexErrMsgIdAndTxt( "MATLAB:cas9_align:invalidInput", 
                "First input argument must be a UINT8 array of the input sequence (as generated by nt2int).");
    }
    
    size_t Lseq;
    Lseq = mxGetN(prhs[0]);    
    
    if (mxGetClassID(prhs[1]) != mxUINT8_CLASS || (mxGetM(prhs[1]) != 1) )  {
	    mexErrMsgIdAndTxt( "MATLAB:cas9_align:invalidInput", 
                "Second input argument must be a UINT8 array of the reference sequence (as generated by nt2int).");
    }
    
    size_t Lref;
    Lref = mxGetN(prhs[1]);
    
    if (!mxIsDouble(prhs[2]) || (mxGetM(prhs[2]) != 1) || (Lref != mxGetN(prhs[2])))  {
	    mexErrMsgIdAndTxt( "MATLAB:cas9_align:invalidInput", 
                "Third input argument must be a double array of opening penalties of length equal to the reference sequence.");
    }
        
    if (!mxIsDouble(prhs[3]) || (mxGetM(prhs[3]) != 1) || (Lref != mxGetN(prhs[3])))  {
	    mexErrMsgIdAndTxt( "MATLAB:cas9_align:invalidInput", 
                "Fourth input argument must be a double array of closing penalties of length equal to the reference sequence.");
    }
    
    if (!mxIsDouble(prhs[4]) || (mxGetM(prhs[4]) != 5) || (mxGetN(prhs[4]) != 5))  {
	    mexErrMsgIdAndTxt( "MATLAB:cas9_align:invalidInput", 
                "Fifth input argument must be a 5x5 double array of substitution scores for [ACGT]x[ACGT].");
    }
    
    #ifndef NDEBUG
    
    cas9_check_input((unsigned char*)mxGetData(prhs[0]), Lseq-1, 
                     (unsigned char*)mxGetData(prhs[1]), Lref-1,
                     (double*)mxGetData(prhs[2]), 
                     (double*)mxGetData(prhs[3]),
                     (double*)mxGetData(prhs[4]));
    #endif
    
    std::vector<unsigned char> al_seq, al_ref;
    
    double best_score = cas9_align((unsigned char*)mxGetData(prhs[0]), Lseq-1, 
                                   (unsigned char*)mxGetData(prhs[1]), Lref-1,
                                   (double*)mxGetData(prhs[2]), 
                                   (double*)mxGetData(prhs[3]),
                                   (double*)mxGetData(prhs[4]), 
                                   al_seq, al_ref);
    
    if (nlhs > 0) {        
        plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL);
        double* sc = (double*)mxGetData(plhs[0]);
        *sc = best_score;        
    }
    
    if (nlhs > 1) {
        
        int Lout = al_seq.size();
    
        unsigned char *dest_ptr, *src_ptr;  
        size_t Nbytes;
        
        plhs[1] = mxCreateNumericMatrix(2, Lout, mxUINT8_CLASS, mxREAL);    
        Nbytes = Lout*mxGetElementSize(plhs[1]);
        dest_ptr = (unsigned char*)mxGetData(plhs[1]);
        
        // Read in the data
        for (int l = 0; l < Lout; l++) {
            dest_ptr[0 + l*2] = al_seq[l];
            dest_ptr[1 + l*2] = al_ref[l];            
        }
    }
}

